#include <iostream>
#include <map>
#include <string>

using namespace std;

//MAP и MULTIMAP в STL (ассоциативные контейнеры)

int main() {
    setlocale(LC_ALL, "RU");
    
    pair<int,string> p(1, "телефон");
    cout << p.first << endl;
    cout << p.second << endl;
    
    map<int, string> myMap;
    
    
    //способы добавления в меп:
    myMap.insert(p);
    myMap.insert(make_pair(2, "ноутбук"));
    myMap.insert(pair<int, string>(3, "компьютер"));
    myMap.emplace(4, "монитор");
    
    myMap.find(3);     //метод find ищет по ключу, в остальном все также, как и в сете, если попытаемся найти элемент, которого нету, то выдаст ошибку, работаем точно также, как с .end() в сете
    
    if(auto it = myMap.find(3) != myMap.end()){
        cout << "Элемент найден" << endl;
    }else{
        cout << "Элемент не найден" << endl;
    }
    
    //также ключ должен быть уникальным, повторных ключей быть не может
    
    cout << myMap[3] << endl;      //получим на экране "компьютер"
    
    //также в отличии от сета и мультисета, значения элементов менять можно, так как, опять же, упорядочивание элементов идет по ключу, вот пример:
    
    myMap[3] = "мышь";
    
    //также можно реализовывать проверки, к примеру:
    
    try{
        myMap.at(5) = "клавиатура";
    }catch(const std::exception &ex){
        cout << ex.what() << endl;;
        cout << "Ошибка нахождения ключа элемента" << endl;
    }
    
    
    return 0;
}

//меп и мультимеп также, как и сет и мультисет имеют структуру бинарного дерева, тоже хранят информацию упорядоченно, но меп и мультимеп хранит пару из значения и ключа

//упорядочивание элементов в дереве идет по ключу, а значение идет просто в подвязку к нему

//отличие мультимепа от мепа такое же, как сета от мультисета: мультимеп может иметь элементы с одинаковыми ключами и еще у мультимепа нет перегрузки оператора [] и метода at()


